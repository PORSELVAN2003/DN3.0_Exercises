Exercise 1: Control Structures

Scenario 1: 
DECLARE
    CURSOR customers_cursor IS
        SELECT CustomerID, DOB, LoanID, InterestRate
        FROM Customers
        INNER JOIN Loans ON Customers.CustomerID = Loans.CustomerID;
    
    customer_rec customers_cursor%ROWTYPE;
BEGIN
    OPEN customers_cursor;
    
    LOOP
        FETCH customers_cursor INTO customer_rec;
        EXIT WHEN customers_cursor%NOTFOUND;
        
        IF TRUNC(MONTHS_BETWEEN(SYSDATE, customer_rec.DOB) / 12) > 60 THEN
            UPDATE Loans
            SET InterestRate = customer_rec.InterestRate * 0.99
            WHERE LoanID = customer_rec.LoanID;
        END IF;
    END LOOP;
    
    CLOSE customers_cursor;
END;
Scenario 2: 
DECLARE
    CURSOR customers_cursor IS
        SELECT CustomerID, Balance
        FROM Customers;
    
    customer_rec customers_cursor%ROWTYPE;
BEGIN
    OPEN customers_cursor;
    
    LOOP
        FETCH customers_cursor INTO customer_rec;
        EXIT WHEN customers_cursor%NOTFOUND;
        
        IF customer_rec.Balance > 10000 THEN
            UPDATE Customers
            SET IsVIP = 'TRUE'
            WHERE CustomerID = customer_rec.CustomerID;
        END IF;
    END LOOP;
    
    CLOSE customers_cursor;
END;

Scenario 3:
DECLARE
    CURSOR loans_cursor IS
        SELECT LoanID, CustomerID, EndDate
        FROM Loans
        WHERE EndDate BETWEEN SYSDATE AND SYSDATE + 30;
    
    loan_rec loans_cursor%ROWTYPE;
BEGIN
    OPEN loans_cursor;
    
    LOOP
        FETCH loans_cursor INTO loan_rec;
        EXIT WHEN loans_cursor%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('Reminder: Loan ' || loan_rec.LoanID || ' for customer ' || loan_rec.CustomerID || ' is due on ' || loan_rec.EndDate);
    END LOOP;
    
    CLOSE loans_cursor;
END;

Exercise 2: Error Handling

Scenario 1: CREATE OR REPLACE PROCEDURE SafeTransferFunds(
    from_account_id NUMBER,
    to_account_id NUMBER,
    amount NUMBER
) AS
BEGIN
    IF amount <= 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Invalid transfer amount');
    END IF;
    
    IF from_account_id = to_account_id THEN
        RAISE_APPLICATION_ERROR(-20002, 'Cannot transfer to the same account');
    END IF;
    
    DECLARE
        from_balance NUMBER;
        to_balance NUMBER;
    BEGIN
        SELECT Balance INTO from_balance
        FROM Accounts
        WHERE AccountID = from_account_id;
        
        IF from_balance < amount THEN
            RAISE_APPLICATION_ERROR(-20003, 'Insufficient funds');
        END IF;
        
        SELECT Balance INTO to_balance
        FROM Accounts
        WHERE AccountID = to_account_id;
        
        UPDATE Accounts
        SET Balance = from_balance - amount
        WHERE AccountID = from_account_id;
        
        UPDATE Accounts
        SET Balance = to_balance + amount
        WHERE AccountID = to_account_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    END;
END;

Scenario 2: 
CREATE OR REPLACE PROCEDURE UpdateSalary(
    employee_id NUMBER,
    percentage NUMBER
) AS
BEGIN
    IF percentage <= 0 THEN
        RAISE_APPLICATION_ERROR(-20004, 'Invalid percentage');
    END IF;
    
    DECLARE
        current_salary NUMBER;
    BEGIN
        SELECT Salary INTO current_salary
        FROM Employees
        WHERE EmployeeID = employee_id;
        
        IF current_salary IS NULL THEN
            RAISE_APPLICATION_ERROR(-20005, 'Employee not found');
        END IF;
        
        UPDATE Employees
        SET Salary = current_salary * (1 + percentage / 100)
        WHERE EmployeeID = employee_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    END;
END;

Scenario 3: 
CREATE OR REPLACE PROCEDURE AddNewCustomer(
    customer_id NUMBER,
    name VARCHAR2,
    dob DATE,
    balance NUMBER
) AS
BEGIN
    IF customer_id IS NULL OR name IS NULL OR dob IS NULL OR balance IS NULL THEN
        RAISE_APPLICATION_ERROR(-20006, 'Invalid customer data');
    END IF;
    
    DECLARE
        existing_customer NUMBER;
    BEGIN
        SELECT CustomerID INTO existing_customer
        FROM Customers
        WHERE CustomerID = customer_id;
        
        IF existing_customer IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20007, 'Customer already exists');
        END IF;
        
        INSERT INTO Customers (CustomerID, Name, DOB, Balance, LastModified)
        VALUES (customer_id, name, dob, balance, SYSDATE);
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
    END;
END;

Exercise 3: Stored Procedures

Scenario 1: 
CREATE OR REPLACE PROCEDURE ProcessMonthlyInterest AS
BEGIN
    UPDATE Accounts
    SET Balance = Balance * 1.01
    WHERE AccountType = 'Savings';
    
    COMMIT;
END;

Scenario 2: 
CREATE OR REPLACE PROCEDURE UpdateEmployeeBonus(
    department VARCHAR2,
    bonus_percentage NUMBER
) AS
BEGIN
    IF bonus_percentage <= 0 THEN
        RAISE_APPLICATION_ERROR(-20008, 'Invalid bonus percentage');
    END IF;
    
    UPDATE Employees
    SET Salary = Salary * (1 + bonus_percentage / 100)
    WHERE Department = department;
    
    COMMIT;
END;

Scenario 3:
CREATE OR REPLACE PROCEDURE TransferFunds(
    from_account_id NUMBER,
    to_account_id NUMBER,
    amount NUMBER
) AS
    from_balance NUMBER;
    to_balance NUMBER;
BEGIN
    IF amount <= 0 THEN
        RAISE_APPLICATION_ERROR(-20009, 'Invalid transfer amount');
    END IF;
    
    IF from_account_id = to_account_id THEN
        RAISE_APPLICATION_ERROR(-20010, 'Cannot transfer to the same account');
    END IF;
    
    SELECT Balance INTO from_balance
    FROM Accounts
    WHERE AccountID = from_account_id;
    
    IF from_balance < amount THEN
        RAISE_APPLICATION_ERROR(-20011, 'Insufficient funds');
    END IF;
    
    SELECT Balance INTO to_balance
    FROM Accounts
    WHERE AccountID = to_account_id;
    
    UPDATE Accounts
    SET Balance = from_balance - amount
    WHERE AccountID = from_account_id;
    
    UPDATE Accounts
    SET Balance = to_balance + amount
    WHERE AccountID = to_account_id;
    
    COMMIT;
END;

Exercise 4: Functions

Scenario 1: 
CREATE OR REPLACE FUNCTION CalculateAge(dob DATE) RETURN NUMBER AS
    age NUMBER;
BEGIN
    age := TRUNC(MONTHS_BETWEEN(SYSDATE, dob) / 12);
    RETURN age;
END;

Scenario 2: 
CREATE OR REPLACE FUNCTION CalculateMonthlyInstallment(
    loan_amount NUMBER,
    interest_rate NUMBER,
    loan_duration NUMBER
) RETURN NUMBER AS
    monthly_installment NUMBER;
BEGIN
    monthly_installment := loan_amount * (interest_rate / 1200) * POWER(1 + interest_rate / 1200, loan_duration * 12) / (POWER(1 + interest_rate / 1200, loan_duration * 12) - 1);
    RETURN monthly_installment;
END;


Scenario 3: 
CREATE OR REPLACE FUNCTION HasSufficientBalance(
    account_id NUMBER,
    amount NUMBER
) RETURN BOOLEAN AS
    balance NUMBER;
BEGIN
    SELECT Balance INTO balance
    FROM Accounts
    WHERE AccountID = account_id;
    
    IF balance >= amount THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;

Exercise 5: Triggers

Scenario 1: 
CREATE OR REPLACE TRIGGER UpdateCustomerLastModified
BEFORE UPDATE ON Customers
FOR EACH ROW
BEGIN
    :NEW.LastModified := SYSTIMESTAMP;
END;

Scenario 2: 
CREATE TABLE AuditLog (
    AuditLogID NUMBER PRIMARY KEY,
    TransactionID NUMBER,
    TransactionDate DATE,
    Amount NUMBER,
    TransactionType VARCHAR2(10),
    LogDate DATE,
    FOREIGN KEY (TransactionID) REFERENCES Transactions(TransactionID)
);

Scenario 3: 
CREATE OR REPLACE TRIGGER LogTransaction
AFTER INSERT ON Transactions
FOR EACH ROW
BEGIN
    INSERT INTO AuditLog (TransactionID, TransactionDate, Amount, TransactionType, LogDate)
    VALUES (:NEW.TransactionID, :NEW.TransactionDate, :NEW.Amount, :NEW.TransactionType, SYSTIMESTAMP);
END;


Exercise 6: Cursors

Scenario 1: 
DECLARE
    CURSOR GenerateMonthlyStatements IS
        SELECT c.CustomerID, c.Name, t.TransactionDate, t.Amount, t.TransactionType
        FROM Customers c
        JOIN Accounts a ON c.CustomerID = a.CustomerID
        JOIN Transactions t ON a.AccountID = t.AccountID
        WHERE TRUNC(t.TransactionDate, 'MM') = TRUNC(SYSDATE, 'MM');
    
    statement_rec GenerateMonthlyStatements%ROWTYPE;
BEGIN
    OPEN GenerateMonthlyStatements;
    LOOP
        FETCH GenerateMonthlyStatements INTO statement_rec;
        EXIT WHEN GenerateMonthlyStatements%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('Customer ID: ' || statement_rec.CustomerID);
        DBMS_OUTPUT.PUT_LINE('Customer Name: ' || statement_rec.Name);
        DBMS_OUTPUT.PUT_LINE('Transaction Date: ' || statement_rec.TransactionDate);
        DBMS_OUTPUT.PUT_LINE('Amount: ' || statement_rec.Amount);
        DBMS_OUTPUT.PUT_LINE('Transaction Type: ' || statement_rec.TransactionType);
        
    END LOOP;
    CLOSE GenerateMonthlyStatements;
END;

Scenario 2: 
DECLARE
    annual_fee NUMBER := 50;  -- assume annual fee is 50
    CURSOR ApplyAnnualFee IS
        SELECT AccountID, Balance
        FROM Accounts;
    
    account_rec ApplyAnnualFee%ROWTYPE;
BEGIN
    OPEN ApplyAnnualFee;
    LOOP
        FETCH ApplyAnnualFee INTO account_rec;
        EXIT WHEN ApplyAnnualFee%NOTFOUND;
        UPDATE Accounts
        SET Balance = account_rec.Balance - annual_fee
        WHERE AccountID = account_rec.AccountID;
    END LOOP;
    CLOSE ApplyAnnualFee;
END;

Scenario 3: 
DECLARE
    new_interest_rate NUMBER := 0.05;  -- assume new interest rate is 5%
    CURSOR UpdateLoanInterestRates IS
        SELECT LoanID, InterestRate
        FROM Loans;
    
    loan_rec UpdateLoanInterestRates%ROWTYPE;
BEGIN
    OPEN UpdateLoanInterestRates;
    LOOP
        FETCH UpdateLoanInterestRates INTO loan_rec;
        EXIT WHEN UpdateLoanInterestRates%NOTFOUND;
        UPDATE Loans
        SET InterestRate = new_interest_rate
        WHERE LoanID = loan_rec.LoanID;
    END LOOP;
    CLOSE UpdateLoanInterestRates;
END;


Exercise 7: Packages

Scenario 1: 
CREATE OR REPLACE PACKAGE CustomerManagement AS
    PROCEDURE AddNewCustomer(p_CustomerID NUMBER, p_Name VARCHAR2, p_DOB DATE);
    PROCEDURE UpdateCustomerDetails(p_CustomerID NUMBER, p_Name VARCHAR2, p_DOB DATE);
    FUNCTION GetCustomerBalance(p_CustomerID NUMBER) RETURN NUMBER;
END CustomerManagement;

CREATE OR REPLACE PACKAGE BODY CustomerManagement AS
    PROCEDURE AddNewCustomer(p_CustomerID NUMBER, p_Name VARCHAR2, p_DOB DATE) IS
    BEGIN
        INSERT INTO Customers (CustomerID, Name, DOB, Balance, LastModified)
        VALUES (p_CustomerID, p_Name, p_DOB, 0, SYSTIMESTAMP);
    END AddNewCustomer;

    PROCEDURE UpdateCustomerDetails(p_CustomerID NUMBER, p_Name VARCHAR2, p_DOB DATE) IS
    BEGIN
        UPDATE Customers
        SET Name = p_Name, DOB = p_DOB, LastModified = SYSTIMESTAMP
        WHERE CustomerID = p_CustomerID;
    END UpdateCustomerDetails;

    FUNCTION GetCustomerBalance(p_CustomerID NUMBER) RETURN NUMBER IS
        v_Balance NUMBER;
    BEGIN
        SELECT SUM(Balance) INTO v_Balance
        FROM Accounts
        WHERE CustomerID = p_CustomerID;
        RETURN v_Balance;
    END GetCustomerBalance;
END CustomerManagement;

Scenario 2: 
CREATE OR REPLACE PACKAGE EmployeeManagement AS
    PROCEDURE HireNewEmployee(p_EmployeeID NUMBER, p_Name VARCHAR2, p_Position VARCHAR2, p_Salary NUMBER, p_Department VARCHAR2, p_HireDate DATE);
    PROCEDURE UpdateEmployeeDetails(p_EmployeeID NUMBER, p_Name VARCHAR2, p_Position VARCHAR2, p_Salary NUMBER, p_Department VARCHAR2);
    FUNCTION CalculateAnnualSalary(p_EmployeeID NUMBER) RETURN NUMBER;
END EmployeeManagement;

CREATE OR REPLACE PACKAGE BODY EmployeeManagement AS
    PROCEDURE HireNewEmployee(p_EmployeeID NUMBER, p_Name VARCHAR2, p_Position VARCHAR2, p_Salary NUMBER, p_Department VARCHAR2, p_HireDate DATE) IS
    BEGIN
        INSERT INTO Employees (EmployeeID, Name, Position, Salary, Department, HireDate)
        VALUES (p_EmployeeID, p_Name, p_Position, p_Salary, p_Department, p_HireDate);
    END HireNewEmployee;

    PROCEDURE UpdateEmployeeDetails(p_EmployeeID NUMBER, p_Name VARCHAR2, p_Position VARCHAR2, p_Salary NUMBER, p_Department VARCHAR2) IS
    BEGIN
        UPDATE Employees
        SET Name = p_Name, Position = p_Position, Salary = p_Salary, Department = p_Department
        WHERE EmployeeID = p_EmployeeID;
    END UpdateEmployeeDetails;

    FUNCTION CalculateAnnualSalary(p_EmployeeID NUMBER) RETURN NUMBER IS
        v_Salary NUMBER;
    BEGIN
        SELECT Salary INTO v_Salary
        FROM Employees
        WHERE EmployeeID = p_EmployeeID;
        RETURN v_Salary * 12;
    END CalculateAnnualSalary;
END EmployeeManagement;

Scenario 3: 
CREATE OR REPLACE PACKAGE AccountOperations AS
    PROCEDURE OpenNewAccount(p_AccountID NUMBER, p_CustomerID NUMBER, p_AccountType VARCHAR2);
    PROCEDURE CloseAccount(p_AccountID NUMBER);
    FUNCTION GetTotalBalance(p_CustomerID NUMBER) RETURN NUMBER;
END AccountOperations;

CREATE OR REPLACE PACKAGE BODY AccountOperations AS
    PROCEDURE OpenNewAccount(p_AccountID NUMBER, p_CustomerID NUMBER, p_AccountType VARCHAR2) IS
    BEGIN
        INSERT INTO Accounts (AccountID, CustomerID, AccountType, Balance, LastModified)
        VALUES (p_AccountID, p_CustomerID, p_AccountType, 0, SYSTIMESTAMP);
    END OpenNewAccount;

    PROCEDURE CloseAccount(p_AccountID NUMBER) IS
    BEGIN
        UPDATE Accounts
        SET LastModified = SYSTIMESTAMP
        WHERE AccountID = p_AccountID;
    END CloseAccount;

    FUNCTION GetTotalBalance(p_CustomerID NUMBER) RETURN NUMBER IS
        v_Balance NUMBER;
    BEGIN
        SELECT SUM(Balance) INTO v_Balance
        FROM Accounts
        WHERE CustomerID = p_CustomerID;
        RETURN v_Balance;
    END GetTotalBalance;
END AccountOperations;





